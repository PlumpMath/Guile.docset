<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual documents Guile version 2.0.11.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2009,
2010, 2011, 2012, 2013, 2014 Free Software Foundation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Guile Reference Manual: R6RS Textual Input</title>

<meta name="description" content="Guile Reference Manual: R6RS Textual Input">
<meta name="keywords" content="Guile Reference Manual: R6RS Textual Input">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="R6RS-I_002fO-Ports.html#R6RS-I_002fO-Ports" rel="up" title="R6RS I/O Ports">
<link href="R6RS-Output-Ports.html#R6RS-Output-Ports" rel="next" title="R6RS Output Ports">
<link href="R6RS-Binary-Input.html#R6RS-Binary-Input" rel="prev" title="R6RS Binary Input">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="R6RS-Textual-Input"></a>
<div class="header">
<p>
Next: <a href="R6RS-Output-Ports.html#R6RS-Output-Ports" accesskey="n" rel="next">R6RS Output Ports</a>, Previous: <a href="R6RS-Binary-Input.html#R6RS-Binary-Input" accesskey="p" rel="prev">R6RS Binary Input</a>, Up: <a href="R6RS-I_002fO-Ports.html#R6RS-I_002fO-Ports" accesskey="u" rel="up">R6RS I/O Ports</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Textual-Input"></a>
<h4 class="subsubsection">6.14.10.9 Textual Input</h4>

<dl>
<dt><a name="index-get_002dchar"></a>Scheme Procedure: <strong>get-char</strong> <em>textual-input-port</em></dt>
<dd><p>Reads from <var>textual-input-port</var>, blocking as necessary, until a
complete character is available from <var>textual-input-port</var>,
or until an end of file is reached.
</p>
<p>If a complete character is available before the next end of file,
<code>get-char</code> returns that character and updates the input port to
point past the character. If an end of file is reached before any
character is read, <code>get-char</code> returns the end-of-file object.
</p></dd></dl>

<dl>
<dt><a name="index-lookahead_002dchar"></a>Scheme Procedure: <strong>lookahead-char</strong> <em>textual-input-port</em></dt>
<dd><p>The <code>lookahead-char</code> procedure is like <code>get-char</code>, but it does
not update <var>textual-input-port</var> to point past the character.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dstring_002dn"></a>Scheme Procedure: <strong>get-string-n</strong> <em>textual-input-port count</em></dt>
<dd>
<p><var>count</var> must be an exact, non-negative integer object, representing
the number of characters to be read.
</p>
<p>The <code>get-string-n</code> procedure reads from <var>textual-input-port</var>,
blocking as necessary, until <var>count</var> characters are available, or
until an end of file is reached.
</p>
<p>If <var>count</var> characters are available before end of file,
<code>get-string-n</code> returns a string consisting of those <var>count</var>
characters. If fewer characters are available before an end of file, but
one or more characters can be read, <code>get-string-n</code> returns a string
containing those characters. In either case, the input port is updated
to point just past the characters read. If no characters can be read
before an end of file, the end-of-file object is returned.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dstring_002dn_0021"></a>Scheme Procedure: <strong>get-string-n!</strong> <em>textual-input-port string start count</em></dt>
<dd>
<p><var>start</var> and <var>count</var> must be exact, non-negative integer objects,
with <var>count</var> representing the number of characters to be read.
<var>string</var> must be a string with at least $<var>start</var> + <var>count</var>$
characters.
</p>
<p>The <code>get-string-n!</code> procedure reads from <var>textual-input-port</var>
in the same manner as <code>get-string-n</code>.  If <var>count</var> characters
are available before an end of file, they are written into <var>string</var>
starting at index <var>start</var>, and <var>count</var> is returned. If fewer
characters are available before an end of file, but one or more can be
read, those characters are written into <var>string</var> starting at index
<var>start</var> and the number of characters actually read is returned as an
exact integer object. If no characters can be read before an end of
file, the end-of-file object is returned.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dstring_002dall"></a>Scheme Procedure: <strong>get-string-all</strong> <em>textual-input-port</em></dt>
<dd><p>Reads from <var>textual-input-port</var> until an end of file, decoding
characters in the same manner as <code>get-string-n</code> and
<code>get-string-n!</code>.
</p>
<p>If characters are available before the end of file, a string containing
all the characters decoded from that data are returned. If no character
precedes the end of file, the end-of-file object is returned.
</p></dd></dl>

<dl>
<dt><a name="index-get_002dline"></a>Scheme Procedure: <strong>get-line</strong> <em>textual-input-port</em></dt>
<dd><p>Reads from <var>textual-input-port</var> up to and including the linefeed
character or end of file, decoding characters in the same manner as
<code>get-string-n</code> and <code>get-string-n!</code>.
</p>
<p>If a linefeed character is read, a string containing all of the text up
to (but not including) the linefeed character is returned, and the port
is updated to point just past the linefeed character. If an end of file
is encountered before any linefeed character is read, but some
characters have been read and decoded as characters, a string containing
those characters is returned. If an end of file is encountered before
any characters are read, the end-of-file object is returned.
</p>
<blockquote>
<p><b>Note:</b> The end-of-line style, if not <code>none</code>, will cause all line endings
  to be read as linefeed characters.  See <a href="R6RS-Transcoders.html#R6RS-Transcoders">R6RS Transcoders</a>.
</p></blockquote>
</dd></dl>

<dl>
<dt><a name="index-get_002ddatum"></a>Scheme Procedure: <strong>get-datum</strong> <em>textual-input-port count</em></dt>
<dd><p>Reads an external representation from <var>textual-input-port</var> and returns the
datum it represents.  The <code>get-datum</code> procedure returns the next
datum that can be parsed from the given <var>textual-input-port</var>, updating
<var>textual-input-port</var> to point exactly past the end of the external
representation of the object.
</p>
<p>Any <em>interlexeme space</em> (comment or whitespace, see <a href="Scheme-Syntax.html#Scheme-Syntax">Scheme Syntax</a>) in the input is first skipped.  If an end of file occurs after
the interlexeme space, the end-of-file object (see <a href="R6RS-End_002dof_002dFile.html#R6RS-End_002dof_002dFile">R6RS End-of-File</a>)
is returned.
</p>
<p>If a character inconsistent with an external representation is
encountered in the input, an exception with condition types
<code>&amp;lexical</code> and <code>&amp;i/o-read</code> is raised.  Also, if the end of
file is encountered after the beginning of an external representation,
but the external representation is incomplete and therefore cannot be
parsed, an exception with condition types <code>&amp;lexical</code> and
<code>&amp;i/o-read</code> is raised.
</p></dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="R6RS-Output-Ports.html#R6RS-Output-Ports" accesskey="n" rel="next">R6RS Output Ports</a>, Previous: <a href="R6RS-Binary-Input.html#R6RS-Binary-Input" accesskey="p" rel="prev">R6RS Binary Input</a>, Up: <a href="R6RS-I_002fO-Ports.html#R6RS-I_002fO-Ports" accesskey="u" rel="up">R6RS I/O Ports</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
