<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual documents Guile version 2.0.11.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2009,
2010, 2011, 2012, 2013, 2014 Free Software Foundation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Guile Reference Manual: Bit Vectors</title>

<meta name="description" content="Guile Reference Manual: Bit Vectors">
<meta name="keywords" content="Guile Reference Manual: Bit Vectors">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Compound-Data-Types.html#Compound-Data-Types" rel="up" title="Compound Data Types">
<link href="Arrays.html#Arrays" rel="next" title="Arrays">
<link href="Uniform-Numeric-Vectors.html#Uniform-Numeric-Vectors" rel="prev" title="Uniform Numeric Vectors">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Bit-Vectors"></a>
<div class="header">
<p>
Next: <a href="Arrays.html#Arrays" accesskey="n" rel="next">Arrays</a>, Previous: <a href="Vectors.html#Vectors" accesskey="p" rel="prev">Vectors</a>, Up: <a href="Compound-Data-Types.html#Compound-Data-Types" accesskey="u" rel="up">Compound Data Types</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Bit-Vectors-1"></a>
<h4 class="subsection">6.7.4 Bit Vectors</h4>

<p>Bit vectors are zero-origin, one-dimensional arrays of booleans.  They
are displayed as a sequence of <code>0</code>s and <code>1</code>s prefixed by
<code>#*</code>, e.g.,
</p>
<div class="example">
<pre class="example">(make-bitvector 8 #f) &rArr;
#*00000000
</pre></div>

<p>Bit vectors are the special case of one dimensional bit arrays, and can
thus be used with the array procedures, See <a href="Arrays.html#Arrays">Arrays</a>.
</p>
<dl>
<dt><a name="index-bitvector_003f"></a>Scheme Procedure: <strong>bitvector?</strong> <em>obj</em></dt>
<dt><a name="index-scm_005fbitvector_005fp"></a>C Function: <strong>scm_bitvector_p</strong> <em>(obj)</em></dt>
<dd><p>Return <code>#t</code> when <var>obj</var> is a bitvector, else
return <code>#f</code>.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fis_005fbitvector"></a>C Function: <em>int</em> <strong>scm_is_bitvector</strong> <em>(SCM obj)</em></dt>
<dd><p>Return <code>1</code> when <var>obj</var> is a bitvector, else return <code>0</code>.
</p></dd></dl>

<dl>
<dt><a name="index-make_002dbitvector"></a>Scheme Procedure: <strong>make-bitvector</strong> <em>len [fill]</em></dt>
<dt><a name="index-scm_005fmake_005fbitvector"></a>C Function: <strong>scm_make_bitvector</strong> <em>(len, fill)</em></dt>
<dd><p>Create a new bitvector of length <var>len</var> and
optionally initialize all elements to <var>fill</var>.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fc_005fmake_005fbitvector"></a>C Function: <em>SCM</em> <strong>scm_c_make_bitvector</strong> <em>(size_t len, SCM fill)</em></dt>
<dd><p>Like <code>scm_make_bitvector</code>, but the length is given as a
<code>size_t</code>.
</p></dd></dl>

<dl>
<dt><a name="index-bitvector"></a>Scheme Procedure: <strong>bitvector</strong> <em>bit &hellip;</em></dt>
<dt><a name="index-scm_005fbitvector"></a>C Function: <strong>scm_bitvector</strong> <em>(bits)</em></dt>
<dd><p>Create a new bitvector with the arguments as elements.
</p></dd></dl>

<dl>
<dt><a name="index-bitvector_002dlength"></a>Scheme Procedure: <strong>bitvector-length</strong> <em>vec</em></dt>
<dt><a name="index-scm_005fbitvector_005flength"></a>C Function: <strong>scm_bitvector_length</strong> <em>(vec)</em></dt>
<dd><p>Return the length of the bitvector <var>vec</var>.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fc_005fbitvector_005flength"></a>C Function: <em>size_t</em> <strong>scm_c_bitvector_length</strong> <em>(SCM vec)</em></dt>
<dd><p>Like <code>scm_bitvector_length</code>, but the length is returned as a
<code>size_t</code>.
</p></dd></dl>

<dl>
<dt><a name="index-bitvector_002dref"></a>Scheme Procedure: <strong>bitvector-ref</strong> <em>vec idx</em></dt>
<dt><a name="index-scm_005fbitvector_005fref"></a>C Function: <strong>scm_bitvector_ref</strong> <em>(vec, idx)</em></dt>
<dd><p>Return the element at index <var>idx</var> of the bitvector
<var>vec</var>.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fc_005fbitvector_005fref"></a>C Function: <em>SCM</em> <strong>scm_c_bitvector_ref</strong> <em>(SCM vec, size_t idx)</em></dt>
<dd><p>Return the element at index <var>idx</var> of the bitvector
<var>vec</var>.
</p></dd></dl>

<dl>
<dt><a name="index-bitvector_002dset_0021"></a>Scheme Procedure: <strong>bitvector-set!</strong> <em>vec idx val</em></dt>
<dt><a name="index-scm_005fbitvector_005fset_005fx"></a>C Function: <strong>scm_bitvector_set_x</strong> <em>(vec, idx, val)</em></dt>
<dd><p>Set the element at index <var>idx</var> of the bitvector
<var>vec</var> when <var>val</var> is true, else clear it.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fc_005fbitvector_005fset_005fx"></a>C Function: <em>SCM</em> <strong>scm_c_bitvector_set_x</strong> <em>(SCM vec, size_t idx, SCM val)</em></dt>
<dd><p>Set the element at index <var>idx</var> of the bitvector
<var>vec</var> when <var>val</var> is true, else clear it.
</p></dd></dl>

<dl>
<dt><a name="index-bitvector_002dfill_0021"></a>Scheme Procedure: <strong>bitvector-fill!</strong> <em>vec val</em></dt>
<dt><a name="index-scm_005fbitvector_005ffill_005fx"></a>C Function: <strong>scm_bitvector_fill_x</strong> <em>(vec, val)</em></dt>
<dd><p>Set all elements of the bitvector
<var>vec</var> when <var>val</var> is true, else clear them.
</p></dd></dl>

<dl>
<dt><a name="index-list_002d_003ebitvector"></a>Scheme Procedure: <strong>list-&gt;bitvector</strong> <em>list</em></dt>
<dt><a name="index-scm_005flist_005fto_005fbitvector"></a>C Function: <strong>scm_list_to_bitvector</strong> <em>(list)</em></dt>
<dd><p>Return a new bitvector initialized with the elements
of <var>list</var>.
</p></dd></dl>

<dl>
<dt><a name="index-bitvector_002d_003elist"></a>Scheme Procedure: <strong>bitvector-&gt;list</strong> <em>vec</em></dt>
<dt><a name="index-scm_005fbitvector_005fto_005flist"></a>C Function: <strong>scm_bitvector_to_list</strong> <em>(vec)</em></dt>
<dd><p>Return a new list initialized with the elements
of the bitvector <var>vec</var>.
</p></dd></dl>

<dl>
<dt><a name="index-bit_002dcount"></a>Scheme Procedure: <strong>bit-count</strong> <em>bool bitvector</em></dt>
<dt><a name="index-scm_005fbit_005fcount"></a>C Function: <strong>scm_bit_count</strong> <em>(bool, bitvector)</em></dt>
<dd><p>Return a count of how many entries in <var>bitvector</var> are equal to
<var>bool</var>.  For example,
</p>
<div class="example">
<pre class="example">(bit-count #f #*000111000)  &rArr; 6
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-bit_002dposition"></a>Scheme Procedure: <strong>bit-position</strong> <em>bool bitvector start</em></dt>
<dt><a name="index-scm_005fbit_005fposition"></a>C Function: <strong>scm_bit_position</strong> <em>(bool, bitvector, start)</em></dt>
<dd><p>Return the index of the first occurrence of <var>bool</var> in
<var>bitvector</var>, starting from <var>start</var>.  If there is no <var>bool</var>
entry between <var>start</var> and the end of <var>bitvector</var>, then return
<code>#f</code>.  For example,
</p>
<div class="example">
<pre class="example">(bit-position #t #*000101 0)  &rArr; 3
(bit-position #f #*0001111 3) &rArr; #f
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-bit_002dinvert_0021"></a>Scheme Procedure: <strong>bit-invert!</strong> <em>bitvector</em></dt>
<dt><a name="index-scm_005fbit_005finvert_005fx"></a>C Function: <strong>scm_bit_invert_x</strong> <em>(bitvector)</em></dt>
<dd><p>Modify <var>bitvector</var> by replacing each element with its negation.
</p></dd></dl>

<dl>
<dt><a name="index-bit_002dset_002a_0021"></a>Scheme Procedure: <strong>bit-set*!</strong> <em>bitvector uvec bool</em></dt>
<dt><a name="index-scm_005fbit_005fset_005fstar_005fx"></a>C Function: <strong>scm_bit_set_star_x</strong> <em>(bitvector, uvec, bool)</em></dt>
<dd><p>Set entries of <var>bitvector</var> to <var>bool</var>, with <var>uvec</var>
selecting the entries to change.  The return value is unspecified.
</p>
<p>If <var>uvec</var> is a bit vector, then those entries where it has
<code>#t</code> are the ones in <var>bitvector</var> which are set to <var>bool</var>.
<var>uvec</var> and <var>bitvector</var> must be the same length.  When
<var>bool</var> is <code>#t</code> it&rsquo;s like <var>uvec</var> is OR&rsquo;ed into
<var>bitvector</var>.  Or when <var>bool</var> is <code>#f</code> it can be seen as an
ANDNOT.
</p>
<div class="example">
<pre class="example">(define bv #*01000010)
(bit-set*! bv #*10010001 #t)
bv
&rArr; #*11010011
</pre></div>

<p>If <var>uvec</var> is a uniform vector of unsigned long integers, then
they&rsquo;re indexes into <var>bitvector</var> which are set to <var>bool</var>.  
</p>
<div class="example">
<pre class="example">(define bv #*01000010)
(bit-set*! bv #u(5 2 7) #t)
bv
&rArr; #*01100111
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-bit_002dcount_002a"></a>Scheme Procedure: <strong>bit-count*</strong> <em>bitvector uvec bool</em></dt>
<dt><a name="index-scm_005fbit_005fcount_005fstar"></a>C Function: <strong>scm_bit_count_star</strong> <em>(bitvector, uvec, bool)</em></dt>
<dd><p>Return a count of how many entries in <var>bitvector</var> are equal to
<var>bool</var>, with <var>uvec</var> selecting the entries to consider.
</p>
<p><var>uvec</var> is interpreted in the same way as for <code>bit-set*!</code>
above.  Namely, if <var>uvec</var> is a bit vector then entries which have
<code>#t</code> there are considered in <var>bitvector</var>.  Or if <var>uvec</var>
is a uniform vector of unsigned long integers then it&rsquo;s the indexes in
<var>bitvector</var> to consider.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example">(bit-count* #*01110111 #*11001101 #t) &rArr; 3
(bit-count* #*01110111 #u(7 0 4) #f)  &rArr; 2
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-scm_005fbitvector_005felements"></a>C Function: <em>const scm_t_uint32 *</em> <strong>scm_bitvector_elements</strong> <em>(SCM vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp, ssize_t *incp)</em></dt>
<dd><p>Like <code>scm_vector_elements</code> (see <a href="Vector-Accessing-from-C.html#Vector-Accessing-from-C">Vector Accessing from C</a>), but
for bitvectors.  The variable pointed to by <var>offp</var> is set to the
value returned by <code>scm_array_handle_bit_elements_offset</code>.  See
<code>scm_array_handle_bit_elements</code> for how to use the returned
pointer and the offset.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fbitvector_005fwritable_005felements"></a>C Function: <em>scm_t_uint32 *</em> <strong>scm_bitvector_writable_elements</strong> <em>(SCM vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp, ssize_t *incp)</em></dt>
<dd><p>Like <code>scm_bitvector_elements</code>, but the pointer is good for reading
and writing.
</p></dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="Arrays.html#Arrays" accesskey="n" rel="next">Arrays</a>, Previous: <a href="Vectors.html#Vectors" accesskey="p" rel="prev">Vectors</a>, Up: <a href="Compound-Data-Types.html#Compound-Data-Types" accesskey="u" rel="up">Compound Data Types</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
