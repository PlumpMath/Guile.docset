<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual documents Guile version 2.0.11.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2009,
2010, 2011, 2012, 2013, 2014 Free Software Foundation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Guile Reference Manual: SRFI-1 Searching</title>

<meta name="description" content="Guile Reference Manual: SRFI-1 Searching">
<meta name="keywords" content="Guile Reference Manual: SRFI-1 Searching">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="SRFI_002d1.html#SRFI_002d1" rel="up" title="SRFI-1">
<link href="SRFI_002d1-Deleting.html#SRFI_002d1-Deleting" rel="next" title="SRFI-1 Deleting">
<link href="SRFI_002d1-Filtering-and-Partitioning.html#SRFI_002d1-Filtering-and-Partitioning" rel="prev" title="SRFI-1 Filtering and Partitioning">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="SRFI_002d1-Searching"></a>
<div class="header">
<p>
Next: <a href="SRFI_002d1-Deleting.html#SRFI_002d1-Deleting" accesskey="n" rel="next">SRFI-1 Deleting</a>, Previous: <a href="SRFI_002d1-Filtering-and-Partitioning.html#SRFI_002d1-Filtering-and-Partitioning" accesskey="p" rel="prev">SRFI-1 Filtering and Partitioning</a>, Up: <a href="SRFI_002d1.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Searching"></a>
<h4 class="subsubsection">7.5.3.7 Searching</h4>
<a name="index-list-search"></a>


<p>The procedures for searching elements in lists either accept a
predicate or a comparison object for determining which elements are to
be searched.
</p>
<dl>
<dt><a name="index-find"></a>Scheme Procedure: <strong>find</strong> <em>pred lst</em></dt>
<dd><p>Return the first element of <var>lst</var> which satisfies the predicate
<var>pred</var> and <code>#f</code> if no such element is found.
</p></dd></dl>

<dl>
<dt><a name="index-find_002dtail"></a>Scheme Procedure: <strong>find-tail</strong> <em>pred lst</em></dt>
<dd><p>Return the first pair of <var>lst</var> whose <small>CAR</small> satisfies the
predicate <var>pred</var> and <code>#f</code> if no such element is found.
</p></dd></dl>

<dl>
<dt><a name="index-take_002dwhile"></a>Scheme Procedure: <strong>take-while</strong> <em>pred lst</em></dt>
<dt><a name="index-take_002dwhile_0021"></a>Scheme Procedure: <strong>take-while!</strong> <em>pred lst</em></dt>
<dd><p>Return the longest initial prefix of <var>lst</var> whose elements all
satisfy the predicate <var>pred</var>.
</p>
<p><code>take-while!</code> is allowed, but not required to modify the input
list while producing the result.
</p></dd></dl>

<dl>
<dt><a name="index-drop_002dwhile"></a>Scheme Procedure: <strong>drop-while</strong> <em>pred lst</em></dt>
<dd><p>Drop the longest initial prefix of <var>lst</var> whose elements all
satisfy the predicate <var>pred</var>.
</p></dd></dl>

<dl>
<dt><a name="index-span"></a>Scheme Procedure: <strong>span</strong> <em>pred lst</em></dt>
<dt><a name="index-span_0021"></a>Scheme Procedure: <strong>span!</strong> <em>pred lst</em></dt>
<dt><a name="index-break-2"></a>Scheme Procedure: <strong>break</strong> <em>pred lst</em></dt>
<dt><a name="index-break_0021"></a>Scheme Procedure: <strong>break!</strong> <em>pred lst</em></dt>
<dd><p><code>span</code> splits the list <var>lst</var> into the longest initial prefix
whose elements all satisfy the predicate <var>pred</var>, and the remaining
tail.  <code>break</code> inverts the sense of the predicate.
</p>
<p><code>span!</code> and <code>break!</code> are allowed, but not required to modify
the structure of the input list <var>lst</var> in order to produce the
result.
</p>
<p>Note that the name <code>break</code> conflicts with the <code>break</code>
binding established by <code>while</code> (see <a href="while-do.html#while-do">while do</a>).  Applications
wanting to use <code>break</code> from within a <code>while</code> loop will need
to make a new define under a different name.
</p></dd></dl>

<dl>
<dt><a name="index-any"></a>Scheme Procedure: <strong>any</strong> <em>pred lst1 lst2 &hellip;</em></dt>
<dd><p>Test whether any set of elements from <var>lst1</var> <var>lst2</var> &hellip;
satisfies <var>pred</var>.  If so, the return value is the return value from
the successful <var>pred</var> call, or if not, the return value is
<code>#f</code>.
</p>
<p>If there are n list arguments, then <var>pred</var> must be a predicate
taking n arguments.  Each <var>pred</var> call is <code>(<var>pred</var>
<var>elem1</var> <var>elem2</var> &hellip; )</code> taking an element from each
<var>lst</var>.  The calls are made successively for the first, second, etc.
elements of the lists, stopping when <var>pred</var> returns non-<code>#f</code>,
or when the end of the shortest list is reached.
</p>
<p>The <var>pred</var> call on the last set of elements (i.e., when the end of
the shortest list has been reached), if that point is reached, is a
tail call.
</p></dd></dl>

<dl>
<dt><a name="index-every"></a>Scheme Procedure: <strong>every</strong> <em>pred lst1 lst2 &hellip;</em></dt>
<dd><p>Test whether every set of elements from <var>lst1</var> <var>lst2</var> &hellip;
satisfies <var>pred</var>.  If so, the return value is the return from the
final <var>pred</var> call, or if not, the return value is <code>#f</code>.
</p>
<p>If there are n list arguments, then <var>pred</var> must be a predicate
taking n arguments.  Each <var>pred</var> call is <code>(<var>pred</var>
<var>elem1</var> <var>elem2 &hellip;</var>)</code> taking an element from each
<var>lst</var>.  The calls are made successively for the first, second, etc.
elements of the lists, stopping if <var>pred</var> returns <code>#f</code>, or when
the end of any of the lists is reached.
</p>
<p>The <var>pred</var> call on the last set of elements (i.e., when the end of
the shortest list has been reached) is a tail call.
</p>
<p>If one of <var>lst1</var> <var>lst2</var> &hellip;is empty then no calls to
<var>pred</var> are made, and the return value is <code>#t</code>.
</p></dd></dl>

<dl>
<dt><a name="index-list_002dindex"></a>Scheme Procedure: <strong>list-index</strong> <em>pred lst1 lst2 &hellip;</em></dt>
<dd><p>Return the index of the first set of elements, one from each of
<var>lst1</var> <var>lst2</var> &hellip;, which satisfies <var>pred</var>.
</p>
<p><var>pred</var> is called as <code>(<var>elem1</var> <var>elem2 &hellip;</var>)</code>.
Searching stops when the end of the shortest <var>lst</var> is reached.
The return index starts from 0 for the first set of elements.  If no
set of elements pass, then the return value is <code>#f</code>.
</p>
<div class="example">
<pre class="example">(list-index odd? '(2 4 6 9))      &rArr; 3
(list-index = '(1 2 3) '(3 1 2))  &rArr; #f
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-member-1"></a>Scheme Procedure: <strong>member</strong> <em>x lst [=]</em></dt>
<dd><p>Return the first sublist of <var>lst</var> whose <small>CAR</small> is equal to
<var>x</var>.  If <var>x</var> does not appear in <var>lst</var>, return <code>#f</code>.
</p>
<p>Equality is determined by <code>equal?</code>, or by the equality predicate
<var>=</var> if given.  <var>=</var> is called <code>(= <var>x</var> elem)</code>,
ie. with the given <var>x</var> first, so for example to find the first
element greater than 5,
</p>
<div class="example">
<pre class="example">(member 5 '(3 5 1 7 2 9) &lt;) &rArr; (7 2 9)
</pre></div>

<p>This version of <code>member</code> extends the core <code>member</code>
(see <a href="List-Searching.html#List-Searching">List Searching</a>) by accepting an equality predicate.
</p></dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="SRFI_002d1-Deleting.html#SRFI_002d1-Deleting" accesskey="n" rel="next">SRFI-1 Deleting</a>, Previous: <a href="SRFI_002d1-Filtering-and-Partitioning.html#SRFI_002d1-Filtering-and-Partitioning" accesskey="p" rel="prev">SRFI-1 Filtering and Partitioning</a>, Up: <a href="SRFI_002d1.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
