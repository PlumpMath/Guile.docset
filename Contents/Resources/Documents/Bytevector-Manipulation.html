<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual documents Guile version 2.0.11.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2009,
2010, 2011, 2012, 2013, 2014 Free Software Foundation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Guile Reference Manual: Bytevector Manipulation</title>

<meta name="description" content="Guile Reference Manual: Bytevector Manipulation">
<meta name="keywords" content="Guile Reference Manual: Bytevector Manipulation">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Bytevectors.html#Bytevectors" rel="up" title="Bytevectors">
<link href="Bytevectors-as-Integers.html#Bytevectors-as-Integers" rel="next" title="Bytevectors as Integers">
<link href="Bytevector-Endianness.html#Bytevector-Endianness" rel="prev" title="Bytevector Endianness">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Bytevector-Manipulation"></a>
<div class="header">
<p>
Next: <a href="Bytevectors-as-Integers.html#Bytevectors-as-Integers" accesskey="n" rel="next">Bytevectors as Integers</a>, Previous: <a href="Bytevector-Endianness.html#Bytevector-Endianness" accesskey="p" rel="prev">Bytevector Endianness</a>, Up: <a href="Bytevectors.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Manipulating-Bytevectors"></a>
<h4 class="subsubsection">6.6.6.2 Manipulating Bytevectors</h4>

<p>Bytevectors can be created, copied, and analyzed with the following
procedures and C functions.
</p>
<dl>
<dt><a name="index-make_002dbytevector"></a>Scheme Procedure: <strong>make-bytevector</strong> <em>len [fill]</em></dt>
<dt><a name="index-scm_005fmake_005fbytevector"></a>C Function: <strong>scm_make_bytevector</strong> <em>(len, fill)</em></dt>
<dt><a name="index-scm_005fc_005fmake_005fbytevector"></a>C Function: <strong>scm_c_make_bytevector</strong> <em>(size_t len)</em></dt>
<dd><p>Return a new bytevector of <var>len</var> bytes.  Optionally, if <var>fill</var>
is given, fill it with <var>fill</var>; <var>fill</var> must be in the range
[-128,255].
</p></dd></dl>

<dl>
<dt><a name="index-bytevector_003f"></a>Scheme Procedure: <strong>bytevector?</strong> <em>obj</em></dt>
<dt><a name="index-scm_005fbytevector_005fp"></a>C Function: <strong>scm_bytevector_p</strong> <em>(obj)</em></dt>
<dd><p>Return true if <var>obj</var> is a bytevector.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fis_005fbytevector"></a>C Function: <em>int</em> <strong>scm_is_bytevector</strong> <em>(SCM obj)</em></dt>
<dd><p>Equivalent to <code>scm_is_true (scm_bytevector_p (obj))</code>.
</p></dd></dl>

<dl>
<dt><a name="index-bytevector_002dlength"></a>Scheme Procedure: <strong>bytevector-length</strong> <em>bv</em></dt>
<dt><a name="index-scm_005fbytevector_005flength"></a>C Function: <strong>scm_bytevector_length</strong> <em>(bv)</em></dt>
<dd><p>Return the length in bytes of bytevector <var>bv</var>.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fc_005fbytevector_005flength"></a>C Function: <em>size_t</em> <strong>scm_c_bytevector_length</strong> <em>(SCM bv)</em></dt>
<dd><p>Likewise, return the length in bytes of bytevector <var>bv</var>.
</p></dd></dl>

<dl>
<dt><a name="index-bytevector_003d_003f"></a>Scheme Procedure: <strong>bytevector=?</strong> <em>bv1 bv2</em></dt>
<dt><a name="index-scm_005fbytevector_005feq_005fp"></a>C Function: <strong>scm_bytevector_eq_p</strong> <em>(bv1, bv2)</em></dt>
<dd><p>Return is <var>bv1</var> equals to <var>bv2</var>&mdash;i.e., if they have the same
length and contents.
</p></dd></dl>

<dl>
<dt><a name="index-bytevector_002dfill_0021"></a>Scheme Procedure: <strong>bytevector-fill!</strong> <em>bv fill</em></dt>
<dt><a name="index-scm_005fbytevector_005ffill_005fx"></a>C Function: <strong>scm_bytevector_fill_x</strong> <em>(bv, fill)</em></dt>
<dd><p>Fill bytevector <var>bv</var> with <var>fill</var>, a byte.
</p></dd></dl>

<dl>
<dt><a name="index-bytevector_002dcopy_0021"></a>Scheme Procedure: <strong>bytevector-copy!</strong> <em>source source-start target target-start len</em></dt>
<dt><a name="index-scm_005fbytevector_005fcopy_005fx"></a>C Function: <strong>scm_bytevector_copy_x</strong> <em>(source, source_start, target, target_start, len)</em></dt>
<dd><p>Copy <var>len</var> bytes from <var>source</var> into <var>target</var>, starting
reading from <var>source-start</var> (a positive index within <var>source</var>)
and start writing at <var>target-start</var>.  It is permitted for the
<var>source</var> and <var>target</var> regions to overlap.
</p></dd></dl>

<dl>
<dt><a name="index-bytevector_002dcopy"></a>Scheme Procedure: <strong>bytevector-copy</strong> <em>bv</em></dt>
<dt><a name="index-scm_005fbytevector_005fcopy"></a>C Function: <strong>scm_bytevector_copy</strong> <em>(bv)</em></dt>
<dd><p>Return a newly allocated copy of <var>bv</var>.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fc_005fbytevector_005fref"></a>C Function: <em>scm_t_uint8</em> <strong>scm_c_bytevector_ref</strong> <em>(SCM bv, size_t index)</em></dt>
<dd><p>Return the byte at <var>index</var> in bytevector <var>bv</var>.
</p></dd></dl>

<dl>
<dt><a name="index-scm_005fc_005fbytevector_005fset_005fx"></a>C Function: <em>void</em> <strong>scm_c_bytevector_set_x</strong> <em>(SCM bv, size_t index, scm_t_uint8 value)</em></dt>
<dd><p>Set the byte at <var>index</var> in <var>bv</var> to <var>value</var>.
</p></dd></dl>

<p>Low-level C macros are available.  They do not perform any
type-checking; as such they should be used with care.
</p>
<dl>
<dt><a name="index-SCM_005fBYTEVECTOR_005fLENGTH"></a>C Macro: <em>size_t</em> <strong>SCM_BYTEVECTOR_LENGTH</strong> <em>(bv)</em></dt>
<dd><p>Return the length in bytes of bytevector <var>bv</var>.
</p></dd></dl>

<dl>
<dt><a name="index-SCM_005fBYTEVECTOR_005fCONTENTS"></a>C Macro: <em>signed char *</em> <strong>SCM_BYTEVECTOR_CONTENTS</strong> <em>(bv)</em></dt>
<dd><p>Return a pointer to the contents of bytevector <var>bv</var>.
</p></dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="Bytevectors-as-Integers.html#Bytevectors-as-Integers" accesskey="n" rel="next">Bytevectors as Integers</a>, Previous: <a href="Bytevector-Endianness.html#Bytevector-Endianness" accesskey="p" rel="prev">Bytevector Endianness</a>, Up: <a href="Bytevectors.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
