<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual documents Guile version 2.0.11.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2009,
2010, 2011, 2012, 2013, 2014 Free Software Foundation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Guile Reference Manual: Latent Typing</title>

<meta name="description" content="Guile Reference Manual: Latent Typing">
<meta name="keywords" content="Guile Reference Manual: Latent Typing">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="About-Data.html#About-Data" rel="up" title="About Data">
<link href="Values-and-Variables.html#Values-and-Variables" rel="next" title="Values and Variables">
<link href="About-Data.html#About-Data" rel="prev" title="About Data">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Latent-Typing"></a>
<div class="header">
<p>
Next: <a href="Values-and-Variables.html#Values-and-Variables" accesskey="n" rel="next">Values and Variables</a>, Up: <a href="About-Data.html#About-Data" accesskey="u" rel="up">About Data</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Latent-Typing-1"></a>
<h4 class="subsection">3.1.1 Latent Typing</h4>

<p>The term <em>latent typing</em> is used to describe a computer language,
such as Scheme, for which you cannot, <em>in general</em>, simply look at
a program&rsquo;s source code and determine what type of data will be
associated with a particular variable, or with the result of a
particular expression.
</p>
<p>Sometimes, of course, you <em>can</em> tell from the code what the type of
an expression will be.  If you have a line in your program that sets the
variable <code>x</code> to the numeric value 1, you can be certain that,
immediately after that line has executed (and in the absence of multiple
threads), <code>x</code> has the numeric value 1.  Or if you write a procedure
that is designed to concatenate two strings, it is likely that the rest
of your application will always invoke this procedure with two string
parameters, and quite probable that the procedure would go wrong in some
way if it was ever invoked with parameters that were not both strings.
</p>
<p>Nevertheless, the point is that there is nothing in Scheme which
requires the procedure parameters always to be strings, or <code>x</code>
always to hold a numeric value, and there is no way of declaring in your
program that such constraints should always be obeyed.  In the same
vein, there is no way to declare the expected type of a procedure&rsquo;s
return value.
</p>
<p>Instead, the types of variables and expressions are only known &ndash; in
general &ndash; at run time.  If you <em>need</em> to check at some point that
a value has the expected type, Scheme provides run time procedures that
you can invoke to do so.  But equally, it can be perfectly valid for two
separate invocations of the same procedure to specify arguments with
different types, and to return values with different types.
</p>
<p>The next subsection explains what this means in practice, for the ways
that Scheme programs use data types, values and variables.
</p>

<hr>
<div class="header">
<p>
Next: <a href="Values-and-Variables.html#Values-and-Variables" accesskey="n" rel="next">Values and Variables</a>, Up: <a href="About-Data.html#About-Data" accesskey="u" rel="up">About Data</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
