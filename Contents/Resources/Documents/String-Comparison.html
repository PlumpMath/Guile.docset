<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual documents Guile version 2.0.11.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2009,
2010, 2011, 2012, 2013, 2014 Free Software Foundation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Guile Reference Manual: String Comparison</title>

<meta name="description" content="Guile Reference Manual: String Comparison">
<meta name="keywords" content="Guile Reference Manual: String Comparison">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Strings.html#Strings" rel="up" title="Strings">
<link href="String-Searching.html#String-Searching" rel="next" title="String Searching">
<link href="String-Modification.html#String-Modification" rel="prev" title="String Modification">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="String-Comparison"></a>
<div class="header">
<p>
Next: <a href="String-Searching.html#String-Searching" accesskey="n" rel="next">String Searching</a>, Previous: <a href="String-Modification.html#String-Modification" accesskey="p" rel="prev">String Modification</a>, Up: <a href="Strings.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="String-Comparison-1"></a>
<h4 class="subsubsection">6.6.5.7 String Comparison</h4>

<p>The procedures in this section are similar to the character ordering
predicates (see <a href="Characters.html#Characters">Characters</a>), but are defined on character sequences.
</p>
<p>The first set is specified in R5RS and has names that end in <code>?</code>.
The second set is specified in SRFI-13 and the names have not ending
<code>?</code>.
</p>
<p>The predicates ending in <code>-ci</code> ignore the character case
when comparing strings.  For now, case-insensitive comparison is done
using the R5RS rules, where every lower-case character that has a
single character upper-case form is converted to uppercase before
comparison.  See See <a href="Text-Collation.html#Text-Collation">the <code>(ice-9
i18n)</code> module</a>, for locale-dependent string comparison.
</p>
<a name="index-string_003d_003f-2"></a>
<dl>
<dt><a name="index-string_003d_003f"></a>Scheme Procedure: <strong>string=?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Lexicographic equality predicate; return <code>#t</code> if all strings are
the same length and contain the same characters in the same positions,
otherwise return <code>#f</code>.
</p>
<p>The procedure <code>string-ci=?</code> treats upper and lower case
letters as though they were the same character, but
<code>string=?</code> treats upper and lower case as distinct
characters.
</p></dd></dl>

<a name="index-string_003c_003f-2"></a>
<dl>
<dt><a name="index-string_003c_003f"></a>Scheme Procedure: <strong>string&lt;?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Lexicographic ordering predicate; return <code>#t</code> if, for every pair of
consecutive string arguments <var>str_i</var> and <var>str_i+1</var>, <var>str_i</var> is
lexicographically less than <var>str_i+1</var>.
</p></dd></dl>

<a name="index-string_003c_003d_003f-2"></a>
<dl>
<dt><a name="index-string_003c_003d_003f"></a>Scheme Procedure: <strong>string&lt;=?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Lexicographic ordering predicate; return <code>#t</code> if, for every pair of
consecutive string arguments <var>str_i</var> and <var>str_i+1</var>, <var>str_i</var> is
lexicographically less than or equal to <var>str_i+1</var>.
</p></dd></dl>

<a name="index-string_003e_003f-2"></a>
<dl>
<dt><a name="index-string_003e_003f"></a>Scheme Procedure: <strong>string&gt;?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Lexicographic ordering predicate; return <code>#t</code> if, for every pair of
consecutive string arguments <var>str_i</var> and <var>str_i+1</var>, <var>str_i</var> is
lexicographically greater than <var>str_i+1</var>.
</p></dd></dl>

<a name="index-string_003e_003d_003f-2"></a>
<dl>
<dt><a name="index-string_003e_003d_003f"></a>Scheme Procedure: <strong>string&gt;=?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Lexicographic ordering predicate; return <code>#t</code> if, for every pair of
consecutive string arguments <var>str_i</var> and <var>str_i+1</var>, <var>str_i</var> is
lexicographically greater than or equal to <var>str_i+1</var>.
</p></dd></dl>

<a name="index-string_002dci_003d_003f-2"></a>
<dl>
<dt><a name="index-string_002dci_003d_003f"></a>Scheme Procedure: <strong>string-ci=?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Case-insensitive string equality predicate; return <code>#t</code> if
all strings are the same length and their component
characters match (ignoring case) at each position; otherwise
return <code>#f</code>.
</p></dd></dl>

<a name="index-string_002dci_003c_003f-2"></a>
<dl>
<dt><a name="index-string_002dci_003c_003f"></a>Scheme Procedure: <strong>string-ci&lt;?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Case insensitive lexicographic ordering predicate; return <code>#t</code> if,
for every pair of consecutive string arguments <var>str_i</var> and
<var>str_i+1</var>, <var>str_i</var> is lexicographically less than <var>str_i+1</var>
regardless of case.
</p></dd></dl>

<a name="index-string_003c_003d_003f-3"></a>
<dl>
<dt><a name="index-string_002dci_003c_003d_003f"></a>Scheme Procedure: <strong>string-ci&lt;=?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Case insensitive lexicographic ordering predicate; return <code>#t</code> if,
for every pair of consecutive string arguments <var>str_i</var> and
<var>str_i+1</var>, <var>str_i</var> is lexicographically less than or equal to
<var>str_i+1</var> regardless of case.
</p></dd></dl>

<a name="index-string_002dci_003e_003f-2"></a>
<dl>
<dt><a name="index-string_002dci_003e_003f"></a>Scheme Procedure: <strong>string-ci&gt;?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Case insensitive lexicographic ordering predicate; return <code>#t</code> if,
for every pair of consecutive string arguments <var>str_i</var> and
<var>str_i+1</var>, <var>str_i</var> is lexicographically greater than
<var>str_i+1</var> regardless of case.
</p></dd></dl>

<a name="index-string_002dci_003e_003d_003f-2"></a>
<dl>
<dt><a name="index-string_002dci_003e_003d_003f"></a>Scheme Procedure: <strong>string-ci&gt;=?</strong> <em>s1 s2 s3 &hellip;</em></dt>
<dd><p>Case insensitive lexicographic ordering predicate; return <code>#t</code> if,
for every pair of consecutive string arguments <var>str_i</var> and
<var>str_i+1</var>, <var>str_i</var> is lexicographically greater than or equal to
<var>str_i+1</var> regardless of case.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dcompare"></a>Scheme Procedure: <strong>string-compare</strong> <em>s1 s2 proc_lt proc_eq proc_gt [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fcompare"></a>C Function: <strong>scm_string_compare</strong> <em>(s1, s2, proc_lt, proc_eq, proc_gt, start1, end1, start2, end2)</em></dt>
<dd><p>Apply <var>proc_lt</var>, <var>proc_eq</var>, <var>proc_gt</var> to the
mismatch index, depending upon whether <var>s1</var> is less than,
equal to, or greater than <var>s2</var>.  The mismatch index is the
largest index <var>i</var> such that for every 0 &lt;= <var>j</var> &lt;
<var>i</var>, <var>s1</var>[<var>j</var>] = <var>s2</var>[<var>j</var>] &ndash; that is,
<var>i</var> is the first position that does not match.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dcompare_002dci"></a>Scheme Procedure: <strong>string-compare-ci</strong> <em>s1 s2 proc_lt proc_eq proc_gt [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fcompare_005fci"></a>C Function: <strong>scm_string_compare_ci</strong> <em>(s1, s2, proc_lt, proc_eq, proc_gt, start1, end1, start2, end2)</em></dt>
<dd><p>Apply <var>proc_lt</var>, <var>proc_eq</var>, <var>proc_gt</var> to the
mismatch index, depending upon whether <var>s1</var> is less than,
equal to, or greater than <var>s2</var>.  The mismatch index is the
largest index <var>i</var> such that for every 0 &lt;= <var>j</var> &lt;
<var>i</var>, <var>s1</var>[<var>j</var>] = <var>s2</var>[<var>j</var>] &ndash; that is,
<var>i</var> is the first position where the lowercased letters 
do not match.
</p>
</dd></dl>

<dl>
<dt><a name="index-string_003d"></a>Scheme Procedure: <strong>string=</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005feq"></a>C Function: <strong>scm_string_eq</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> and <var>s2</var> are not equal, a true
value otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-string_003c_003e"></a>Scheme Procedure: <strong>string&lt;&gt;</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fneq"></a>C Function: <strong>scm_string_neq</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> and <var>s2</var> are equal, a true
value otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-string_003c"></a>Scheme Procedure: <strong>string&lt;</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005flt"></a>C Function: <strong>scm_string_lt</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> is greater or equal to <var>s2</var>, a
true value otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-string_003e"></a>Scheme Procedure: <strong>string&gt;</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fgt"></a>C Function: <strong>scm_string_gt</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> is less or equal to <var>s2</var>, a
true value otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-string_003c_003d"></a>Scheme Procedure: <strong>string&lt;=</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fle"></a>C Function: <strong>scm_string_le</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> is greater to <var>s2</var>, a true
value otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-string_003e_003d"></a>Scheme Procedure: <strong>string&gt;=</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fge"></a>C Function: <strong>scm_string_ge</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> is less to <var>s2</var>, a true value
otherwise.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dci_003d"></a>Scheme Procedure: <strong>string-ci=</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fci_005feq"></a>C Function: <strong>scm_string_ci_eq</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> and <var>s2</var> are not equal, a true
value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dci_003c_003e"></a>Scheme Procedure: <strong>string-ci&lt;&gt;</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fci_005fneq"></a>C Function: <strong>scm_string_ci_neq</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> and <var>s2</var> are equal, a true
value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dci_003c"></a>Scheme Procedure: <strong>string-ci&lt;</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fci_005flt"></a>C Function: <strong>scm_string_ci_lt</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> is greater or equal to <var>s2</var>, a
true value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dci_003e"></a>Scheme Procedure: <strong>string-ci&gt;</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fci_005fgt"></a>C Function: <strong>scm_string_ci_gt</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> is less or equal to <var>s2</var>, a
true value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dci_003c_003d"></a>Scheme Procedure: <strong>string-ci&lt;=</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fci_005fle"></a>C Function: <strong>scm_string_ci_le</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> is greater to <var>s2</var>, a true
value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dci_003e_003d"></a>Scheme Procedure: <strong>string-ci&gt;=</strong> <em>s1 s2 [start1 [end1 [start2 [end2]]]]</em></dt>
<dt><a name="index-scm_005fstring_005fci_005fge"></a>C Function: <strong>scm_string_ci_ge</strong> <em>(s1, s2, start1, end1, start2, end2)</em></dt>
<dd><p>Return <code>#f</code> if <var>s1</var> is less to <var>s2</var>, a true value
otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dhash"></a>Scheme Procedure: <strong>string-hash</strong> <em>s [bound [start [end]]]</em></dt>
<dt><a name="index-scm_005fsubstring_005fhash"></a>C Function: <strong>scm_substring_hash</strong> <em>(s, bound, start, end)</em></dt>
<dd><p>Compute a hash value for <var>s</var>.  The optional argument <var>bound</var> is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).
</p></dd></dl>

<dl>
<dt><a name="index-string_002dhash_002dci"></a>Scheme Procedure: <strong>string-hash-ci</strong> <em>s [bound [start [end]]]</em></dt>
<dt><a name="index-scm_005fsubstring_005fhash_005fci"></a>C Function: <strong>scm_substring_hash_ci</strong> <em>(s, bound, start, end)</em></dt>
<dd><p>Compute a hash value for <var>s</var>.  The optional argument <var>bound</var> is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).
</p></dd></dl>

<p>Because the same visual appearance of an abstract Unicode character can 
be obtained via multiple sequences of Unicode characters, even the 
case-insensitive string comparison functions described above may return
<code>#f</code> when presented with strings containing different 
representations of the same character.  For example, the Unicode 
character &ldquo;LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE&rdquo; can be 
represented with a single character (U+1E69) or by the character &ldquo;LATIN
SMALL LETTER S&rdquo; (U+0073) followed by the combining marks &ldquo;COMBINING 
DOT BELOW&rdquo; (U+0323) and &ldquo;COMBINING DOT ABOVE&rdquo; (U+0307).
</p>
<p>For this reason, it is often desirable to ensure that the strings
to be compared are using a mutually consistent representation for every 
character.  The Unicode standard defines two methods of normalizing the
contents of strings: Decomposition, which breaks composite characters 
into a set of constituent characters with an ordering defined by the
Unicode Standard; and composition, which performs the converse.
</p>
<p>There are two decomposition operations.  &ldquo;Canonical decomposition&rdquo; 
produces character sequences that share the same visual appearance as
the original characters, while &ldquo;compatibility decomposition&rdquo; produces
ones whose visual appearances may differ from the originals but which
represent the same abstract character.
</p>
<p>These operations are encapsulated in the following set of normalization
forms:
</p>
<dl compact="compact">
<dt><em>NFD</em></dt>
<dd><p>Characters are decomposed to their canonical forms.
</p>
</dd>
<dt><em>NFKD</em></dt>
<dd><p>Characters are decomposed to their compatibility forms.
</p>
</dd>
<dt><em>NFC</em></dt>
<dd><p>Characters are decomposed to their canonical forms, then composed.
</p>
</dd>
<dt><em>NFKC</em></dt>
<dd><p>Characters are decomposed to their compatibility forms, then composed.
</p>
</dd>
</dl>

<p>The functions below put their arguments into one of the forms described
above.
</p>
<dl>
<dt><a name="index-string_002dnormalize_002dnfd"></a>Scheme Procedure: <strong>string-normalize-nfd</strong> <em>s</em></dt>
<dt><a name="index-scm_005fstring_005fnormalize_005fnfd"></a>C Function: <strong>scm_string_normalize_nfd</strong> <em>(s)</em></dt>
<dd><p>Return the <code>NFD</code> normalized form of <var>s</var>.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dnormalize_002dnfkd"></a>Scheme Procedure: <strong>string-normalize-nfkd</strong> <em>s</em></dt>
<dt><a name="index-scm_005fstring_005fnormalize_005fnfkd"></a>C Function: <strong>scm_string_normalize_nfkd</strong> <em>(s)</em></dt>
<dd><p>Return the <code>NFKD</code> normalized form of <var>s</var>.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dnormalize_002dnfc"></a>Scheme Procedure: <strong>string-normalize-nfc</strong> <em>s</em></dt>
<dt><a name="index-scm_005fstring_005fnormalize_005fnfc"></a>C Function: <strong>scm_string_normalize_nfc</strong> <em>(s)</em></dt>
<dd><p>Return the <code>NFC</code> normalized form of <var>s</var>.
</p></dd></dl>

<dl>
<dt><a name="index-string_002dnormalize_002dnfkc"></a>Scheme Procedure: <strong>string-normalize-nfkc</strong> <em>s</em></dt>
<dt><a name="index-scm_005fstring_005fnormalize_005fnfkc"></a>C Function: <strong>scm_string_normalize_nfkc</strong> <em>(s)</em></dt>
<dd><p>Return the <code>NFKC</code> normalized form of <var>s</var>.
</p></dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="String-Searching.html#String-Searching" accesskey="n" rel="next">String Searching</a>, Previous: <a href="String-Modification.html#String-Modification" accesskey="p" rel="prev">String Modification</a>, Up: <a href="Strings.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
