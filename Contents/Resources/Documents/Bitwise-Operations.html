<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual documents Guile version 2.0.11.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2009,
2010, 2011, 2012, 2013, 2014 Free Software Foundation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License." -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Guile Reference Manual: Bitwise Operations</title>

<meta name="description" content="Guile Reference Manual: Bitwise Operations">
<meta name="keywords" content="Guile Reference Manual: Bitwise Operations">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Numbers.html#Numbers" rel="up" title="Numbers">
<link href="Random.html#Random" rel="next" title="Random">
<link href="Scientific.html#Scientific" rel="prev" title="Scientific">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Bitwise-Operations"></a>
<div class="header">
<p>
Next: <a href="Random.html#Random" accesskey="n" rel="next">Random</a>, Previous: <a href="Scientific.html#Scientific" accesskey="p" rel="prev">Scientific</a>, Up: <a href="Numbers.html#Numbers" accesskey="u" rel="up">Numbers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Bitwise-Operations-1"></a>
<h4 class="subsubsection">6.6.2.13 Bitwise Operations</h4>

<p>For the following bitwise functions, negative numbers are treated as
infinite precision twos-complements.  For instance <em>-6</em> is bits
<em>&hellip;111010</em>, with infinitely many ones on the left.  It can
be seen that adding 6 (binary 110) to such a bit pattern gives all
zeros.
</p>
<dl>
<dt><a name="index-logand"></a>Scheme Procedure: <strong>logand</strong> <em>n1 n2 &hellip;</em></dt>
<dt><a name="index-scm_005flogand"></a>C Function: <strong>scm_logand</strong> <em>(n1, n2)</em></dt>
<dd><p>Return the bitwise <small>AND</small> of the integer arguments.
</p>
<div class="lisp">
<pre class="lisp">(logand) &rArr; -1
(logand 7) &rArr; 7
(logand #b111 #b011 #b001) &rArr; 1
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-logior"></a>Scheme Procedure: <strong>logior</strong> <em>n1 n2 &hellip;</em></dt>
<dt><a name="index-scm_005flogior"></a>C Function: <strong>scm_logior</strong> <em>(n1, n2)</em></dt>
<dd><p>Return the bitwise <small>OR</small> of the integer arguments.
</p>
<div class="lisp">
<pre class="lisp">(logior) &rArr; 0
(logior 7) &rArr; 7
(logior #b000 #b001 #b011) &rArr; 3
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-logxor"></a>Scheme Procedure: <strong>logxor</strong> <em>n1 n2 &hellip;</em></dt>
<dt><a name="index-scm_005floxor"></a>C Function: <strong>scm_loxor</strong> <em>(n1, n2)</em></dt>
<dd><p>Return the bitwise <small>XOR</small> of the integer arguments.  A bit is
set in the result if it is set in an odd number of arguments.
</p>
<div class="lisp">
<pre class="lisp">(logxor) &rArr; 0
(logxor 7) &rArr; 7
(logxor #b000 #b001 #b011) &rArr; 2
(logxor #b000 #b001 #b011 #b011) &rArr; 1
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-lognot"></a>Scheme Procedure: <strong>lognot</strong> <em>n</em></dt>
<dt><a name="index-scm_005flognot"></a>C Function: <strong>scm_lognot</strong> <em>(n)</em></dt>
<dd><p>Return the integer which is the ones-complement of the integer
argument, ie. each 0 bit is changed to 1 and each 1 bit to 0.
</p>
<div class="lisp">
<pre class="lisp">(number-&gt;string (lognot #b10000000) 2)
   &rArr; &quot;-10000001&quot;
(number-&gt;string (lognot #b0) 2)
   &rArr; &quot;-1&quot;
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-logtest"></a>Scheme Procedure: <strong>logtest</strong> <em>j k</em></dt>
<dt><a name="index-scm_005flogtest"></a>C Function: <strong>scm_logtest</strong> <em>(j, k)</em></dt>
<dd><p>Test whether <var>j</var> and <var>k</var> have any 1 bits in common.  This is
equivalent to <code>(not (zero? (logand j k)))</code>, but without actually
calculating the <code>logand</code>, just testing for non-zero.
</p>
<div class="lisp">
<pre class="lisp">(logtest #b0100 #b1011) &rArr; #f
(logtest #b0100 #b0111) &rArr; #t
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-logbit_003f"></a>Scheme Procedure: <strong>logbit?</strong> <em>index j</em></dt>
<dt><a name="index-scm_005flogbit_005fp"></a>C Function: <strong>scm_logbit_p</strong> <em>(index, j)</em></dt>
<dd><p>Test whether bit number <var>index</var> in <var>j</var> is set.  <var>index</var>
starts from 0 for the least significant bit.
</p>
<div class="lisp">
<pre class="lisp">(logbit? 0 #b1101) &rArr; #t
(logbit? 1 #b1101) &rArr; #f
(logbit? 2 #b1101) &rArr; #t
(logbit? 3 #b1101) &rArr; #t
(logbit? 4 #b1101) &rArr; #f
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-ash"></a>Scheme Procedure: <strong>ash</strong> <em>n count</em></dt>
<dt><a name="index-scm_005fash"></a>C Function: <strong>scm_ash</strong> <em>(n, count)</em></dt>
<dd><p>Return <em>floor(n * 2^count)</em>.
<var>n</var> and <var>count</var> must be exact integers.
</p>
<p>With <var>n</var> viewed as an infinite-precision twos-complement
integer, <code>ash</code> means a left shift introducing zero bits
when <var>count</var> is positive, or a right shift dropping bits
when <var>count</var> is negative.  This is an &ldquo;arithmetic&rdquo; shift.
</p>
<div class="lisp">
<pre class="lisp">(number-&gt;string (ash #b1 3) 2)     &rArr; &quot;1000&quot;
(number-&gt;string (ash #b1010 -1) 2) &rArr; &quot;101&quot;

;; -23 is bits ...11101001, -6 is bits ...111010
(ash -23 -2) &rArr; -6
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-round_002dash"></a>Scheme Procedure: <strong>round-ash</strong> <em>n count</em></dt>
<dt><a name="index-scm_005fround_005fash"></a>C Function: <strong>scm_round_ash</strong> <em>(n, count)</em></dt>
<dd><p>Return <em>round(n * 2^count)</em>.
<var>n</var> and <var>count</var> must be exact integers.
</p>
<p>With <var>n</var> viewed as an infinite-precision twos-complement
integer, <code>round-ash</code> means a left shift introducing zero
bits when <var>count</var> is positive, or a right shift rounding
to the nearest integer (with ties going to the nearest even
integer) when <var>count</var> is negative.  This is a rounded
&ldquo;arithmetic&rdquo; shift.
</p>
<div class="lisp">
<pre class="lisp">(number-&gt;string (round-ash #b1 3) 2)     &rArr; \&quot;1000\&quot;
(number-&gt;string (round-ash #b1010 -1) 2) &rArr; \&quot;101\&quot;
(number-&gt;string (round-ash #b1010 -2) 2) &rArr; \&quot;10\&quot;
(number-&gt;string (round-ash #b1011 -2) 2) &rArr; \&quot;11\&quot;
(number-&gt;string (round-ash #b1101 -2) 2) &rArr; \&quot;11\&quot;
(number-&gt;string (round-ash #b1110 -2) 2) &rArr; \&quot;100\&quot;
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-logcount"></a>Scheme Procedure: <strong>logcount</strong> <em>n</em></dt>
<dt><a name="index-scm_005flogcount"></a>C Function: <strong>scm_logcount</strong> <em>(n)</em></dt>
<dd><p>Return the number of bits in integer <var>n</var>.  If <var>n</var> is
positive, the 1-bits in its binary representation are counted.
If negative, the 0-bits in its two&rsquo;s-complement binary
representation are counted.  If zero, 0 is returned.
</p>
<div class="lisp">
<pre class="lisp">(logcount #b10101010)
   &rArr; 4
(logcount 0)
   &rArr; 0
(logcount -2)
   &rArr; 1
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-integer_002dlength"></a>Scheme Procedure: <strong>integer-length</strong> <em>n</em></dt>
<dt><a name="index-scm_005finteger_005flength"></a>C Function: <strong>scm_integer_length</strong> <em>(n)</em></dt>
<dd><p>Return the number of bits necessary to represent <var>n</var>.
</p>
<p>For positive <var>n</var> this is how many bits to the most significant one
bit.  For negative <var>n</var> it&rsquo;s how many bits to the most significant
zero bit in twos complement form.
</p>
<div class="lisp">
<pre class="lisp">(integer-length #b10101010) &rArr; 8
(integer-length #b1111)     &rArr; 4
(integer-length 0)          &rArr; 0
(integer-length -1)         &rArr; 0
(integer-length -256)       &rArr; 8
(integer-length -257)       &rArr; 9
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-integer_002dexpt"></a>Scheme Procedure: <strong>integer-expt</strong> <em>n k</em></dt>
<dt><a name="index-scm_005finteger_005fexpt"></a>C Function: <strong>scm_integer_expt</strong> <em>(n, k)</em></dt>
<dd><p>Return <var>n</var> raised to the power <var>k</var>.  <var>k</var> must be an exact
integer, <var>n</var> can be any number.
</p>
<p>Negative <var>k</var> is supported, and results in <em>1/n^abs(k)</em>
in the usual way.  <em><var>n</var>^0</em> is 1, as usual, and that includes
<em>0^0</em> is 1.
</p>
<div class="lisp">
<pre class="lisp">(integer-expt 2 5)   &rArr; 32
(integer-expt -3 3)  &rArr; -27
(integer-expt 5 -3)  &rArr; 1/125
(integer-expt 0 0)   &rArr; 1
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-bit_002dextract"></a>Scheme Procedure: <strong>bit-extract</strong> <em>n start end</em></dt>
<dt><a name="index-scm_005fbit_005fextract"></a>C Function: <strong>scm_bit_extract</strong> <em>(n, start, end)</em></dt>
<dd><p>Return the integer composed of the <var>start</var> (inclusive)
through <var>end</var> (exclusive) bits of <var>n</var>.  The
<var>start</var>th bit becomes the 0-th bit in the result.
</p>
<div class="lisp">
<pre class="lisp">(number-&gt;string (bit-extract #b1101101010 0 4) 2)
   &rArr; &quot;1010&quot;
(number-&gt;string (bit-extract #b1101101010 4 9) 2)
   &rArr; &quot;10110&quot;
</pre></div>
</dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="Random.html#Random" accesskey="n" rel="next">Random</a>, Previous: <a href="Scientific.html#Scientific" accesskey="p" rel="prev">Scientific</a>, Up: <a href="Numbers.html#Numbers" accesskey="u" rel="up">Numbers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
